"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RustGenerator = exports.ConstrainedSupportFileModel = exports.defaultRustRenderCompleteModelOptions = exports.RustPackageFeatures = void 0;
const AbstractGenerator_1 = require("../AbstractGenerator");
const models_1 = require("../../models");
const helpers_1 = require("../../helpers");
const RustPreset_1 = require("./RustPreset");
const StructRenderer_1 = require("./renderers/StructRenderer");
const EnumRenderer_1 = require("./renderers/EnumRenderer");
const LoggingInterface_1 = require("../../utils/LoggingInterface");
const RustConstrainer_1 = require("./RustConstrainer");
const TupleRenderer_1 = require("./renderers/TupleRenderer");
const UnionRenderer_1 = require("./renderers/UnionRenderer");
const PackageRenderer_1 = require("./renderers/PackageRenderer");
const Partials_1 = require("../../utils/Partials");
const RustDependencyManager_1 = require("./RustDependencyManager");
var RustPackageFeatures;
(function (RustPackageFeatures) {
    RustPackageFeatures[RustPackageFeatures["json"] = 0] = "json";
})(RustPackageFeatures = exports.RustPackageFeatures || (exports.RustPackageFeatures = {}));
exports.defaultRustRenderCompleteModelOptions = {
    supportFiles: true,
    package: {
        // Many of these options can be parsed from schema?
        packageName: 'asyncapi-rs-models',
        packageVersion: '0.0.0',
        authors: ['AsyncAPI Rust Champions'],
        homepage: 'https://www.asyncapi.com/tools/modelina',
        repository: 'https://github.com/asyncapi/modelina',
        license: 'Apache-2.0',
        description: 'Rust models generated by AsyncAPI Modelina',
        edition: '2018',
        packageFeatures: [RustPackageFeatures.json]
    }
};
class ConstrainedSupportFileModel extends models_1.ConstrainedMetaModel {
}
exports.ConstrainedSupportFileModel = ConstrainedSupportFileModel;
/**
 * Generator for Rust
 */
class RustGenerator extends AbstractGenerator_1.AbstractGenerator {
    constructor(options) {
        const realizedOptions = RustGenerator.getRustOptions(options);
        super('Rust', realizedOptions);
    }
    /**
     * Returns the Rust options by merging custom options with default ones.
     */
    static getRustOptions(options) {
        const optionsToUse = (0, Partials_1.mergePartialAndDefault)(RustGenerator.defaultOptions, options);
        //Always overwrite the dependency manager unless user explicitly state they want it (ignore default temporary dependency manager)
        if ((options === null || options === void 0 ? void 0 : options.dependencyManager) === undefined) {
            optionsToUse.dependencyManager = () => {
                return new RustDependencyManager_1.RustDependencyManager(optionsToUse);
            };
        }
        return optionsToUse;
    }
    /**
     * Returns the Rust options by merging custom options with default ones.
     */
    static getRustCompleteOptions(options) {
        return (0, Partials_1.mergePartialAndDefault)(exports.defaultRustRenderCompleteModelOptions, options);
    }
    /**
     * Wrapper to get an instance of the dependency manager
     */
    getDependencyManager(options) {
        return this.getDependencyManagerInstance(options);
    }
    splitMetaModel(model) {
        //These are the models that we have separate renderers for
        const metaModelsToSplit = {
            splitEnum: true,
            splitObject: true,
            splitTuple: true,
            splitArray: false,
            splitUnion: true
        };
        return (0, helpers_1.split)(model, metaModelsToSplit);
    }
    constrainToMetaModel(model, options) {
        const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
        const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
        return (0, helpers_1.constrainMetaModel)(this.options.typeMapping, this.options.constraints, {
            metaModel: model,
            dependencyManager: dependencyManagerToUse,
            options: this.options,
            constrainedName: '' //This is just a placeholder, it will be constrained within the function
        });
    }
    render(model, inputModel, options) {
        const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
        if (model instanceof models_1.ConstrainedObjectModel) {
            return this.renderStruct(model, inputModel, optionsToUse);
        }
        else if (model instanceof models_1.ConstrainedEnumModel) {
            return this.renderEnum(model, inputModel, optionsToUse);
        }
        else if (model instanceof models_1.ConstrainedTupleModel) {
            return this.renderTuple(model, inputModel, optionsToUse);
        }
        else if (model instanceof models_1.ConstrainedUnionModel) {
            return this.renderUnion(model, inputModel, optionsToUse);
        }
        LoggingInterface_1.Logger.warn(`Rust generator, cannot generate this type of model, ${model.name}`);
        return Promise.resolve(models_1.RenderOutput.toRenderOutput({
            result: '',
            renderedName: '',
            dependencies: []
        }));
    }
    /**
     * Render a complete model result where the model code, library and model dependencies are all bundled appropriately.
     *
     * @param model
     * @param inputModel
     * @param options
     */
    renderCompleteModel(model, inputModel, _completeModelOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            LoggingInterface_1.Logger.debug('Generating complete models with options: ', optionsToUse);
            const outputModel = yield this.render(model, inputModel);
            const outputContent = outputModel.result;
            return models_1.RenderOutput.toRenderOutput({
                result: outputContent,
                renderedName: outputModel.renderedName,
                dependencies: outputModel.dependencies
            });
        });
    }
    renderEnum(model, inputModel, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
            const presets = this.getPresets('enum');
            const renderer = new EnumRenderer_1.EnumRenderer(optionsToUse, this, presets, model, inputModel, dependencyManagerToUse);
            const result = yield renderer.runSelfPreset();
            return models_1.RenderOutput.toRenderOutput({
                result,
                renderedName: model.name,
                dependencies: dependencyManagerToUse.dependencies
            });
        });
    }
    renderStruct(model, inputModel, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
            const presets = this.getPresets('struct');
            const renderer = new StructRenderer_1.StructRenderer(optionsToUse, this, presets, model, inputModel, dependencyManagerToUse);
            const result = yield renderer.runSelfPreset();
            return models_1.RenderOutput.toRenderOutput({
                result,
                renderedName: model.name,
                dependencies: dependencyManagerToUse.dependencies
            });
        });
    }
    renderTuple(model, inputModel, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
            const presets = this.getPresets('tuple');
            const renderer = new TupleRenderer_1.TupleRenderer(optionsToUse, this, presets, model, inputModel, dependencyManagerToUse);
            const result = yield renderer.runSelfPreset();
            return models_1.RenderOutput.toRenderOutput({
                result,
                renderedName: model.name,
                dependencies: dependencyManagerToUse.dependencies
            });
        });
    }
    renderUnion(model, inputModel, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
            const presets = this.getPresets('union');
            const renderer = new UnionRenderer_1.UnionRenderer(optionsToUse, this, presets, model, inputModel, dependencyManagerToUse);
            const result = yield renderer.runSelfPreset();
            return models_1.RenderOutput.toRenderOutput({
                result,
                renderedName: model.name,
                dependencies: dependencyManagerToUse.dependencies
            });
        });
    }
    renderManifest(model, inputModel, completeModelOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
            const presets = this.getPresets('package');
            const renderer = new PackageRenderer_1.PackageRenderer(optionsToUse, this, presets, model, inputModel, dependencyManagerToUse);
            const result = yield renderer.runPreset('manifest', {
                packageOptions: completeModelOptions.package,
                inputModel
            });
            return models_1.RenderOutput.toRenderOutput({
                result,
                renderedName: model.name,
                dependencies: dependencyManagerToUse.dependencies
            });
        });
    }
    renderLib(model, inputModel, completeModelOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const optionsToUse = RustGenerator.getRustOptions(Object.assign(Object.assign({}, this.options), options));
            const dependencyManagerToUse = this.getDependencyManager(optionsToUse);
            const presets = this.getPresets('package');
            const renderer = new PackageRenderer_1.PackageRenderer(optionsToUse, this, presets, model, inputModel, dependencyManagerToUse);
            const result = yield renderer.runPreset('lib', {
                packageOptions: completeModelOptions.package,
                inputModel
            });
            return models_1.RenderOutput.toRenderOutput({
                result,
                renderedName: model.name,
                dependencies: dependencyManagerToUse.dependencies
            });
        });
    }
    generateCompleteSupport(input, completeModelOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const inputModel = yield this.processInput(input);
            const manifestMetaModel = new ConstrainedSupportFileModel('Cargo.toml', inputModel, 'supportFile');
            const libMetaModel = new ConstrainedSupportFileModel('src/lib.rs', inputModel, 'supportFile');
            const manifestOutput = yield this.renderManifest(manifestMetaModel, inputModel, completeModelOptions, options);
            const libOutput = yield this.renderLib(libMetaModel, inputModel, completeModelOptions, options);
            return [
                models_1.OutputModel.toOutputModel({
                    result: manifestOutput.result,
                    modelName: 'CargoToml',
                    dependencies: manifestOutput.dependencies,
                    model: manifestMetaModel,
                    inputModel
                }),
                models_1.OutputModel.toOutputModel({
                    result: libOutput.result,
                    modelName: 'lib',
                    dependencies: libOutput.dependencies,
                    model: libMetaModel,
                    inputModel
                })
            ];
        });
    }
}
exports.RustGenerator = RustGenerator;
RustGenerator.defaultOptions = Object.assign(Object.assign({}, AbstractGenerator_1.defaultGeneratorOptions), { defaultPreset: RustPreset_1.RUST_DEFAULT_PRESET, typeMapping: RustConstrainer_1.RustDefaultTypeMapping, constraints: RustConstrainer_1.RustDefaultConstraints, indentation: {
        type: helpers_1.IndentationTypes.SPACES,
        size: 4
    }, 
    // Temporarily set
    dependencyManager: () => {
        return {};
    } });
//# sourceMappingURL=RustGenerator.js.map